<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>松山大学士</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gwtjs.github.io/"/>
  <updated>2019-08-04T11:47:13.247Z</updated>
  <id>http://gwtjs.github.io/</id>
  
  <author>
    <name>gwtjs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/"/>
    <id>http://gwtjs.github.io/photos/收藏的桌面壁纸/</id>
    <published>2019-08-04T11:47:13.247Z</published>
    <updated>2019-08-04T11:47:13.247Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/046a8497636afce032b336392b32821c.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/046a8497636afce032b336392b32821c.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/0516151b15b57be4be6c5ba6c47b2b7a.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/0516151b15b57be4be6c5ba6c47b2b7a.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/11aeac67126d88a6b1555a8b466f5084.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/11aeac67126d88a6b1555a8b466f5084.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/1539327e19a9c9c3dfee0b4f65ae3374.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/1539327e19a9c9c3dfee0b4f65ae3374.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/154417192921.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/154417192921.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/1544171940218.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/1544171940218.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/1544171973305.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/1544171973305.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/1544172021422.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/1544172021422.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/2382182f49588bb2afbe797c243b311b.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/2382182f49588bb2afbe797c243b311b.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/3fe2041930e28d689c4f2d29f8a7e055.jpeg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/3fe2041930e28d689c4f2d29f8a7e055.jpeg.thumbnail.jpeg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/46a2172e46c1294334a74c0efd3bef1a.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/46a2172e46c1294334a74c0efd3bef1a.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/537008.png" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/537008.png.thumbnail.png" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/56cad5dbd0e0bdf8c5efbf8dd3aea580.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/56cad5dbd0e0bdf8c5efbf8dd3aea580.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/5b1bf4f3ae301d62da8f150028fd5591.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/5b1bf4f3ae301d62da8f150028fd5591.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/69619cf5faf28d8ded4522c875d725d5.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/69619cf5faf28d8ded4522c875d725d5.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/76c6393dc83a034ee0a5ec252c828b3d.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/76c6393dc83a034ee0a5ec252c828b3d.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/7eb12855e1417e6a2af5292c1e802ff4.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/7eb12855e1417e6a2af5292c1e802ff4.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/84940.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/84940.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/84953.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/84953.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/aab2c9f6068926b813a26c7a818e8628.jpeg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/aab2c9f6068926b813a26c7a818e8628.jpeg.thumbnail.jpeg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/b7677533ae67267ba061308681a2accf.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/b7677533ae67267ba061308681a2accf.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/c848218e93e59098eab0b4e85d992133.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/c848218e93e59098eab0b4e85d992133.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/c8521651a9973bf22f612f5a65cba77c.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/c8521651a9973bf22f612f5a65cba77c.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/d34d1a6385f6698a65437346d09fc31f.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/d34d1a6385f6698a65437346d09fc31f.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/ed7c871371e277a2e0d98d13ba00b239.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/ed7c871371e277a2e0d98d13ba00b239.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/f39782fb26c6f434119b9d570dfaddae.png" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/f39782fb26c6f434119b9d570dfaddae.png.thumbnail.png" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/fc40e82571a95f724dc9d3c018dce15d.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/fc40e82571a95f724dc9d3c018dce15d.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/ff4f91bef4d6c6bde177a3adc3625c29.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/ff4f91bef4d6c6bde177a3adc3625c29.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/himouto_umaru_chan-003.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/himouto_umaru_chan-003.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/noragami-004.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/noragami-004.jpg.thumbnail.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/timg.jpg" alt><img src="/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/timg.jpg.thumbnail.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/photos/%E6%94%B6%E8%97%8F%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8/046a8497636afce032b336392b32821c.jpg&quot; alt&gt;&lt;img src=&quot;/ph
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/vue/%E6%8C%87%E4%BB%A4&amp;%E6%8F%92%E6%A7%BD/"/>
    <id>http://gwtjs.github.io/programming/vue/指令&amp;插槽/</id>
    <published>2019-07-31T16:16:43.480Z</published>
    <updated>2019-04-18T15:22:59.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义指令的实现"><a href="#自定义指令的实现" class="headerlink" title="自定义指令的实现"></a>自定义指令的实现</h1><h2 id="全局注册-amp-局部注册"><a href="#全局注册-amp-局部注册" class="headerlink" title="全局注册 &amp; 局部注册"></a>全局注册 &amp; 局部注册</h2><blockquote><p>除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。</p><p>注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p></blockquote><pre><code>// 注册一个全局自定义指令 `v-focus`Vue.directive(&apos;focus&apos;, {  // 当被绑定的元素插入到 DOM 中时……  inserted: function (el) {    // 聚焦元素    el.focus()  }})// 在组件内使用directives选项进行局部注册directives: {  focus: {    // 指令的定义    inserted: function (el) {      el.focus()    }  }}// 使用&lt;input v-focus&gt;</code></pre><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><blockquote><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p><p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p><p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。</p><p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p><p>unbind：只调用一次，指令与元素解绑时调用。</p></blockquote><h2 id="钩子函数的参数"><a href="#钩子函数的参数" class="headerlink" title="钩子函数的参数"></a>钩子函数的参数</h2><blockquote><p>指令钩子函数会被传入以下参数：</p><p>el：指令所绑定的元素，可以用来直接操作 DOM 。</p><p>binding：一个对象，包含以下属性：</p><ul><li>name：指令名，不包括 v前缀。</li><li>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</li><li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li><li>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li><li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li><li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li></ul><p>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</p><p>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</p></blockquote><h1 id="指令列表"><a href="#指令列表" class="headerlink" title="指令列表"></a>指令列表</h1><h2 id="v-text【基本不使用】"><a href="#v-text【基本不使用】" class="headerlink" title="v-text【基本不使用】"></a>v-text【基本不使用】</h2><p><strong>描述：</strong></p><blockquote><p>更新元素的 textContent。如果要更新部分的 textContent ，需要使用  插值。</p></blockquote><p><strong>例子：</strong></p><pre><code>&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;&lt;!-- 和下面的一样 --&gt;&lt;span&gt;{{msg}}&lt;/span&gt;</code></pre><h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p><strong>描述：</strong></p><blockquote><p>更新元素的 innerHTML 。</p><p>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。<br>注意：在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。</p><p>注意：在单文件组件里，scoped 的样式不会应用在 v-html 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 v-html 的内容设置带作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局<code>&lt;style&gt;</code>元素手动设置类似 BEM 的作用域策略。</p></blockquote><p><strong>例子：</strong></p><pre><code>// htmlStr将会被渲染，即下面这个div会被替换成htmlStr的值&lt;div v-html=&quot;htmlStr&quot;&gt;&lt;/div&gt;</code></pre><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p><strong>描述：</strong></p><blockquote><p>根据表达式之真假值，切换元素的 display CSS 属性。</p><p>当条件变化时该指令触发过渡效果。</p></blockquote><p><strong>例子：</strong></p><pre><code>&lt;div v-show=&quot;isShow&quot;&gt;显示/隐藏&lt;/div&gt;</code></pre><h2 id="v-if-amp-v-else-amp-v-else-if"><a href="#v-if-amp-v-else-amp-v-else-if" class="headerlink" title="v-if &amp; v-else &amp; v-else-if"></a>v-if &amp; v-else &amp; v-else-if</h2><p><strong>描述：</strong></p><blockquote><p>v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是<code>&lt;template&gt;</code>，将提出它的内容作为条件块。当条件变化时该指令触发过渡效果。</p><p>使用v-else或者v-else-if时，前一兄弟元素必须有 v-if 或 v-else-if。</p><p>注意： 当和 v-if 一起使用时，v-for 的优先级比 v-if 更高</p></blockquote><p><strong>例子：</strong></p><pre><code>// v-if 将分别重复运行于每个 v-for 循环中，只有isComplete为false的li会被渲染。// 当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用。&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;  {{ todo }}&lt;/li&gt;// 条件判断&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;  A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;  B&lt;/div&gt;&lt;div v-else&gt;  Not A/B&lt;/div&gt;</code></pre><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p><strong>描述：</strong></p><blockquote><p>值：Array | Object | number | string | Iterable (2.6 新增)</p></blockquote><p><strong>例子：</strong></p><pre><code>&lt;div v-for=&quot;(item, index) in items&quot;&gt;&lt;/div&gt;&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt;&lt;div v-for=&quot;(val, key, index) in object&quot;&gt;&lt;/div&gt;</code></pre><h2 id="v-on【简写-】"><a href="#v-on【简写-】" class="headerlink" title="v-on【简写@】"></a>v-on【简写@】</h2><p><strong>描述：</strong></p><blockquote><p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p></blockquote><blockquote><p>用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。</p></blockquote><blockquote><p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：v-on:click=”handle(‘ok’, $event)”。</p></blockquote><blockquote><p>从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。</p></blockquote><p><strong>修饰符：</strong></p><ul><li>stop 调用 event.stopPropagation()。</li><li>prevent 调用 event.preventDefault()。</li><li>capture 添加事件侦听器时使用 capture 模式。</li><li>self 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li><li>{keyCode | keyAlias} 只当事件是从特定键触发时才触发回调。</li><li>native 监听组件根元素的原生事件。</li><li>once 只触发一次回调。</li><li>left (2.2.0) 只当点击鼠标左键时触发。</li><li>right (2.2.0) 只当点击鼠标右键时触发。</li><li>middle (2.2.0) 只当点击鼠标中键时触发。</li><li>passive (2.3.0) 以 { passive: true } 模式添加侦听器</li></ul><p><strong>例子：</strong></p><pre><code>&lt;!-- 缩写 --&gt;&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 动态事件缩写 (2.6.0+) --&gt;&lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 对象语法 (2.4.0+) --&gt;&lt;button v-on=&quot;{ mousedown: doThis, mouseup: doThat }&quot;&gt;&lt;/button&gt;</code></pre><h2 id="v-bind【简写-】"><a href="#v-bind【简写-】" class="headerlink" title="v-bind【简写:】"></a>v-bind【简写:】</h2><p><strong>描述：</strong></p><blockquote><p>动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p></blockquote><blockquote><p>在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p></blockquote><blockquote><p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p></blockquote><blockquote><p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。</p></blockquote><p><strong>修饰符：</strong></p><ul><li>prop 被用于绑定 DOM 属性 (property)。(差别在哪里？)</li><li>camel (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)</li><li>sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。</li></ul><p><strong>例子：</strong></p><pre><code>&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;&lt;!-- 动态特性名缩写 (2.6.0+) --&gt;&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind=&quot;{ id: someProp, &apos;other-attr&apos;: otherProp }&quot;&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;</code></pre><p><strong>关于.sync修饰符说明</strong></p><blockquote><p>因双向数据绑定存在维护上的问题，推荐使用update:myPropName 的模式触发事件取而代之。这种模式的缩写就是.sync修饰符。</p><p>注意：带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。</p><p>注意：将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p></blockquote><pre><code>// 在组件内部触发update:myPropName事件this.$emit(&apos;update:title&apos;, newTitle)// 使用该组件&lt;text-document  v-bind:title=&quot;doc.title&quot;  v-on:update:title=&quot;doc.title = $event&quot;&gt;&lt;/text-document&gt;// 以.sync修饰符的方式使用该组件&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;// 使用一个对象，设置多个属性&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;</code></pre><h2 id="v-model【双向数据绑定】"><a href="#v-model【双向数据绑定】" class="headerlink" title="v-model【双向数据绑定】"></a>v-model【双向数据绑定】</h2><p><strong>描述：</strong></p><blockquote><p>在表单控件或者组件上创建双向绑定。只能在<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>及自定义组件上使用。</p><p>v-model 在内部使用不同的属性为不同的输入元素并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul></blockquote><p><strong>修饰符：</strong></p><ul><li>lazy 取代 input 监听 change 事件</li><li>number 输入字符串转为有效的数字</li><li>trim 输入首尾空格过滤</li></ul><p><strong>例子：</strong></p><pre><code>// 多行输入框&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=&quot;white-space: pre-line;&quot;&gt;{{ message }}&lt;/p&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;// 单行输入框&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;&lt;p&gt;Message is: {{ message }}&lt;/p&gt;// 单个复选框，值为boolean&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;// 多个复选框，值为数组&lt;div id=&apos;example-3&apos;&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;  &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;  &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;  &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;  &lt;br&gt;  &lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt;&lt;/div&gt;</code></pre><p><strong>关于在组件上使用v-model的说明</strong></p><pre><code>// 一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，// 但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突Vue.component(&apos;base-checkbox&apos;, {  model: {    prop: &apos;checked&apos;,    event: &apos;change&apos;  },  props: {    checked: Boolean  },  template: `    &lt;input      type=&quot;checkbox&quot;      v-bind:checked=&quot;checked&quot;      v-on:change=&quot;$emit(&apos;change&apos;, $event.target.checked)&quot;    &gt;  `})&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</code></pre><h2 id="v-slot【简写-】"><a href="#v-slot【简写-】" class="headerlink" title="v-slot【简写#】"></a>v-slot【简写#】</h2><p><strong>描述：</strong></p><blockquote><p>只能用于<code>&lt;template&gt;</code>或组件 (对于一个单独的带 prop 的默认插槽)</p><p>注意：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p></blockquote><p><strong>例子：</strong></p><pre><code>// 插槽后备内容，也就是默认的显示内容&lt;submit-button&gt;&lt;/submit-button&gt;&lt;button type=&quot;submit&quot;&gt;  &lt;slot&gt;这是默认的内容&lt;/slot&gt;&lt;/button&gt;// 父级模板无法访问内部子模板的数据&lt;navigation-link url=&quot;/profile&quot;&gt;  Clicking here will send you to: {{ url }}  &lt;!--  这里的 `url` 会是 undefined，因为 &quot;/profile&quot; 是  _传递给_ &lt;navigation-link&gt; 的而不是  在 &lt;navigation-link&gt; 组件*内部*定义的。  --&gt;&lt;/navigation-link&gt;// 作用域插槽，通过在内部子模板绑定数据的方式，让父模板可以访问内部子模板的数据&lt;current-user&gt;  &lt;template v-slot:default=&quot;slotProps&quot;&gt;    {{ slotProps.user.firstName }}  &lt;/template&gt;&lt;/current-user&gt;&lt;span&gt;  &lt;slot v-bind:user=&quot;user&quot;&gt;    {{ user.lastName }}  &lt;/slot&gt;&lt;/span&gt;&lt;!-- 具名插槽 --&gt;&lt;base-layout&gt;  &lt;template v-slot:header&gt;    Header content  &lt;/template&gt;  Default slot content  &lt;template v-slot:footer&gt;    Footer content  &lt;/template&gt;&lt;/base-layout&gt;&lt;!-- 接收 prop 的具名插槽 --&gt;&lt;infinite-scroll&gt;  &lt;template v-slot:item=&quot;slotProps&quot;&gt;    &lt;div class=&quot;item&quot;&gt;      {{ slotProps.item.text }}    &lt;/div&gt;  &lt;/template&gt;&lt;/infinite-scroll&gt;&lt;!-- 接收 prop 的默认插槽，使用了解构 --&gt;&lt;mouse-position v-slot=&quot;{ x, y }&quot;&gt;  Mouse position: {{ x }}, {{ y }}&lt;/mouse-position&gt;</code></pre><h2 id="v-pre【性能优化】"><a href="#v-pre【性能优化】" class="headerlink" title="v-pre【性能优化】"></a>v-pre【性能优化】</h2><p><strong>描述：</strong></p><blockquote><p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p></blockquote><p><strong>例子：</strong></p><pre><code>&lt;div v-pre&gt;    &lt;div&gt;        &lt;span&gt;例子&lt;/span&gt;        &lt;span&gt;例子&lt;/span&gt;        &lt;span&gt;例子&lt;/span&gt;        &lt;span&gt;例子&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;例子&lt;/div&gt;    &lt;div&gt;例子&lt;/div&gt;    &lt;div&gt;例子&lt;/div&gt;&lt;/div&gt;</code></pre><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><p><strong>描述：</strong></p><blockquote><p>这个指令保持在元素上直到关联实例结束编译。</p><p>作用在于实例创建完成之前标识该元素，例如跟[v-cloak] { display: none } 一起用，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p></blockquote><p><strong>例子：</strong></p><pre><code>// 实例编译完成之前，该元素隐藏[v-cloak] {  display: none;}&lt;div v-cloak&gt;  {{ message }}&lt;/div&gt;</code></pre><h2 id="v-once【性能优化】"><a href="#v-once【性能优化】" class="headerlink" title="v-once【性能优化】"></a>v-once【性能优化】</h2><p><strong>描述：</strong></p><blockquote><p>只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p></blockquote><p><strong>例子</strong></p><pre><code>&lt;!-- 单个元素 --&gt;&lt;span v-once&gt;This will never change: {{msg}}&lt;/span&gt;&lt;!-- 有子元素 --&gt;&lt;div v-once&gt;  &lt;h1&gt;comment&lt;/h1&gt;  &lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt;&lt;!-- 组件 --&gt;&lt;my-component v-once :comment=&quot;msg&quot;&gt;&lt;/my-component&gt;&lt;!-- `v-for` 指令--&gt;&lt;ul&gt;  &lt;li v-for=&quot;i in list&quot; v-once&gt;{{i}}&lt;/li&gt;&lt;/ul&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义指令的实现&quot;&gt;&lt;a href=&quot;#自定义指令的实现&quot; class=&quot;headerlink&quot; title=&quot;自定义指令的实现&quot;&gt;&lt;/a&gt;自定义指令的实现&lt;/h1&gt;&lt;h2 id=&quot;全局注册-amp-局部注册&quot;&gt;&lt;a href=&quot;#全局注册-amp-局部注册&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/vue/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://gwtjs.github.io/programming/vue/vue组件通信总结/</id>
    <published>2019-07-31T16:16:43.464Z</published>
    <updated>2019-05-26T10:25:54.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="props-emit"><a href="#props-emit" class="headerlink" title="props/$emit"></a>props/$emit</h1><blockquote><p>适合父子组件通信</p><p>父组件使用 props 传递数据到子组件</p><p>子组件使用 $emit 触发绑定到自身的事件调用父组件中的回调函数将数据传入</p></blockquote><h1 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h1><blockquote><p>适合跨级组件向下传递数据</p><p>祖先组件将需要传递的数据放入自身 provide 选项中</p></blockquote><blockquote><p>子孙组件使用 inject 选项接收从祖先组件传入的数据</p></blockquote><h1 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs/$listeners"></a>$attrs/$listeners</h1><blockquote><p>适合跨级组件通信</p><p>祖先组件将需要传递的数据通过 v-bind 传入中间组件、通过v-on将事件传入中间组件</p></blockquote><blockquote><p>中间组件使用 v-bind=”$attrs” 将数据层层往下传递数据、使用 v-on=”$listeners” 将事件层层往下传递</p></blockquote><blockquote><p>子孙组件使用直接从props中接收祖先组件的数据、使用 this.$emit 触发祖先组件上的事件</p></blockquote><blockquote><p>注意：$attrs 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上,因此通过设置 inheritAttrs=false，将这些默认行为去掉。</p></blockquote><blockquote><p>注意：$listeners 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。</p></blockquote><h1 id="on-emit"><a href="#on-emit" class="headerlink" title="$on/$emit"></a>$on/$emit</h1><blockquote><p>适合父子组件、跨级组件、兄弟组件等所有情况的组件通信</p></blockquote><blockquote><p>通过创建一个新的Vue实例，并使用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 在需要监听某事件的地方调用 ```this.$bus.$on(&apos;someEvent&apos;,callback)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在需要触发某事件的地方调用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># vuex</span><br><span class="line">&gt; 适合父子组件、跨级组件、兄弟组件等所有情况的组件通信</span><br><span class="line"></span><br><span class="line">&gt; 通过vuex插件引入$store及相关map方法（如mapState、mapGetters）</span><br><span class="line"></span><br><span class="line">&gt; 在需要改变数据的地方调用 ```this.$store.commit(&apos;mutation&apos;,params)、this.$store.dispatch(&apos;action&apos;,params)、mapMutations()、mapActions()</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在需要使用数据的地方调用 <code>mapState()、mapGetters()</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;props-emit&quot;&gt;&lt;a href=&quot;#props-emit&quot; class=&quot;headerlink&quot; title=&quot;props/$emit&quot;&gt;&lt;/a&gt;props/$emit&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;适合父子组件通信&lt;/p&gt;
&lt;p&gt;父组件使用 p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/react/demos/demo01/package/"/>
    <id>http://gwtjs.github.io/programming/react/demos/demo01/package/</id>
    <published>2019-07-31T16:16:43.336Z</published>
    <updated>2019-05-30T15:41:19.624Z</updated>
    
    <content type="html"><![CDATA[{"name":"demo01","version":"0.1.0","private":true}]]></content>
    
    <summary type="html">
    
      
      
        {&quot;name&quot;:&quot;demo01&quot;,&quot;version&quot;:&quot;0.1.0&quot;,&quot;private&quot;:true}
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/nodejs/test/"/>
    <id>http://gwtjs.github.io/programming/nodejs/test/</id>
    <published>2019-07-31T16:16:43.305Z</published>
    <updated>2019-04-22T16:21:51.982Z</updated>
    
    <content type="html"><![CDATA[<image xlink:href="a.svg"><img src="./gwtjs-1.png" alt><img src="./gwtjs-2.png" alt><img src="./gwtjs-3.png" alt><img src="./gwtjs-4.png" alt><img src="./gwtjs-5.png" alt><img src="./gwtjs-2-1.png" alt><img src="./gwtjs-2-2.png" alt><img src="./gwtjs.png" alt><image width="350" height="350" x="75" y="120" cursor="pointer" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeYAAAIlCAMAAAA32at6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRF////AAAAVcLTfgAAAAF0Uk5TAEDm2GYAAAEcSURBVHja7MExAQAAAMKg9U9tCU+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG4mwAAUnwABSto4TAAAAABJRU5ErkJggg=="></image></image>]]></content>
    
    <summary type="html">
    
      
      
        &lt;image xlink:href=&quot;a.svg&quot;&gt;
&lt;img src=&quot;./gwtjs-1.png&quot; alt&gt;
&lt;img src=&quot;./gwtjs-2.png&quot; alt&gt;
&lt;img src=&quot;./gwtjs-3.png&quot; alt&gt;
&lt;img src=&quot;./gwtjs-4.png
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/nodejs/img/"/>
    <id>http://gwtjs.github.io/programming/nodejs/img/</id>
    <published>2019-07-31T16:16:43.289Z</published>
    <updated>2019-04-22T15:30:20.067Z</updated>
    
    <content type="html"><![CDATA[const fs = require("fs");function base64_decode(base64str, file) {  // create buffer object from base64 encoded string, it is important to tell the constructor that the string is base64 encoded  var bitmap = new Buffer.from(base64str, "base64");  // write buffer to file  fs.writeFileSync(file, bitmap);  console.log("******** File created from base64 encoded string ********");}base64_decode(  `iVBORw0KGgoAAAANSUhEUgAAAeYAAAIlCAMAAAA32at6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRF\/\/\/\/AAAAVcLTfgAAAAF0Uk5TAEDm2GYAAAEcSURBVHja7MExAQAAAMKg9U9tCU+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG4mwAAUnwABSto4TAAAAABJRU5ErkJggg==`,  "a.svg");]]></content>
    
    <summary type="html">
    
      
      
        const fs = require(&quot;fs&quot;);
function base64_decode(base64str, file) {
  // create buffer object from base64 encoded string, it is important to
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/es6/Promise/"/>
    <id>http://gwtjs.github.io/programming/es6/Promise/</id>
    <published>2019-07-31T16:15:51.936Z</published>
    <updated>2019-04-21T10:56:13.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">function Promise(cb)&#123;</span><br><span class="line">    this.state = &apos;pending&apos;</span><br><span class="line">    this.value = undefined</span><br><span class="line">    this.error = undefined</span><br><span class="line">    </span><br><span class="line">    function resolve(value) &#123;</span><br><span class="line">        this.value = value</span><br><span class="line">        this.state = &apos;fulfill&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(error) &#123;</span><br><span class="line">        this.error = error</span><br><span class="line">        this.state = &apos;rejected&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    await (async function()&#123;</span><br><span class="line">        cb(resolve, reject);</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onfulfilled,onrejected)&#123;</span><br><span class="line">    var newPromise;</span><br><span class="line">    try &#123;</span><br><span class="line">        if(this.state === &apos;rejected&apos;) &#123;</span><br><span class="line">            newPromise = Promise.reject(onrejected(this.error));</span><br><span class="line">        &#125;</span><br><span class="line">        newPromise = Promise.resolve(onfulfilled(this.value));</span><br><span class="line">    &#125;catch(e) &#123;</span><br><span class="line">        newPromise = Promise.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.catch = function(onrejected)&#123;</span><br><span class="line">    this.then(null, onrejected)</span><br><span class="line">&#125;</span><br><span class="line">Promise.prototype.finally = function(onFinally)&#123;</span><br><span class="line">    onFinally()</span><br><span class="line">    if(this.state === &apos;fulfill&apos;) &#123;</span><br><span class="line">        return this.value</span><br><span class="line">    &#125;</span><br><span class="line">    return this.error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.all = function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.race = function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.resolve = function(value)&#123;</span><br><span class="line">    return new Promise(function()&#123;</span><br><span class="line">        this.state = &apos;fulfill&apos;</span><br><span class="line">        this.value = value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.reject = function(reason)&#123;</span><br><span class="line">    return new Promise(function()&#123;</span><br><span class="line">        this.state = &apos;rejected&apos;</span><br><span class="line">        this.error = reason</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h1&gt;&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;figur
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/es6/async%E3%80%81await/"/>
    <id>http://gwtjs.github.io/programming/es6/async、await/</id>
    <published>2019-07-31T16:15:51.905Z</published>
    <updated>2019-04-21T10:56:08.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function name([param[, param[, ... param]]]) &#123; statements &#125;</span><br></pre></td></tr></table></figure><p>async function 声明用于定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数。</p><p>async/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>实质上async函数中，在await语句之后的代码都将在异步回调中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getData() &#123;</span><br><span class="line">    return new Promise(function(resolve,reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&apos;timeout run&apos;)</span><br><span class="line">            resolve(100)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function test() &#123;</span><br><span class="line">    console.log(&apos;test run&apos;)</span><br><span class="line">    var data = await getData()</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>以上代码将与下面的代码达到一样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getData() &#123;</span><br><span class="line">    return new Promise(function(resolve,reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&apos;timeout run&apos;)</span><br><span class="line">            resolve(100)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    return Promise.resolve().then(function()&#123;</span><br><span class="line">        console.log(&apos;test run&apos;)</span><br><span class="line">        return getData().then(function(value)&#123;</span><br><span class="line">            var data = value;</span><br><span class="line">            console.log(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/es5/%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
    <id>http://gwtjs.github.io/programming/es5/类和继承/</id>
    <published>2019-07-31T16:15:51.889Z</published>
    <updated>2019-04-21T10:56:02.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类定义主要有以下几种方式：</p><ol><li><p>工厂方式，存在语义上不像创建类实例（未使用new构造函数），每个实例都创建了方法的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createA(name) &#123;</span><br><span class="line">    var a = new Object;</span><br><span class="line">    a.name = name;</span><br><span class="line">    a.getName = function()&#123;&#125;;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数方式，存在每个实例都创建了方法的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function A(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.getName = function()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>原型方式，存在无法向构造函数传参，每个实例属性都一样的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.name = &apos;a&apos;;</span><br><span class="line">A.prototype.getName = function()&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数及原型混合方式，较为完美，但方法定义在构造函数外部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function A(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getName = function()&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态原型方式，基本与混合方式一致，区别在于将方法定义在构造函数内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    if(!A._inited) &#123;</span><br><span class="line">        A.prototype.getName = function()&#123;&#125;</span><br><span class="line">        A._inited = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>class方式,只是es6语法糖，内部基本与构造函数/原型缓和方式一致，constructor对应构造函数,static成员添加到构造函数，其余成员添加到构造函数的原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    static a = 5</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    static getValue()&#123;&#125;</span><br><span class="line">    getName()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 等同于</span><br><span class="line">function A(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">A.a = 5;</span><br><span class="line">A.getValue = function()&#123;&#125;</span><br><span class="line">A.prototy.getName = funciton()&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>javascript继承只能是单继承，可使用拷贝方式实现多继承效果。</p><ol><li><p>混合方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Super(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function Sub(name, value) &#123;</span><br><span class="line">    Super.call(this,name);</span><br><span class="line">    this.value = value;</span><br><span class="line">&#125;</span><br><span class="line">// 此处不直接Sub.prototype = new Super()是因为这样的话Super的属性会附加在Sub.prototype上</span><br><span class="line">function F()&#123;&#125;</span><br><span class="line">F.prototype = Super.prototype;</span><br><span class="line">Sub.prototype = new F()</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.getValue = function()&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>object.create方式<br>基本与混合方式一致，区别在于无需使用中间的构造函数F，而是使用Object.create()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function F()&#123;&#125;</span><br><span class="line">F.prototype = Super.prototype;</span><br><span class="line">Sub.prototype = new F()</span><br><span class="line">// 以上代码替换为</span><br><span class="line">Sub.prototype = Object.create(Super.prototype)</span><br></pre></td></tr></table></figure></li><li><p>拷贝方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype = Object.assign(&#123;&#125;,Super.prototype,A.prototype,B.prototype,&#123;</span><br><span class="line">    constructor:Sub,</span><br><span class="line">    otherProp: &apos;&apos;,</span><br><span class="line">    otherFunction: function()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>class extends方式，只是es6语法糖，内部实现基本与object.create方式一致,super相当于A.call(this)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extend A&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">     super()   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h1&gt;&lt;p&gt;类定义主要有以下几种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;工厂方式，存在语义上不像创建类实例（未使用new构造函数），每个实例都创建了方法的问题。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/es5/%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81instanceof/"/>
    <id>http://gwtjs.github.io/programming/es5/原型、原型链、instanceof/</id>
    <published>2019-07-31T16:15:51.811Z</published>
    <updated>2019-04-21T10:56:07.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>prototype属性指向原型对象，<strong>proto</strong>属性指向构造函数的原型。</p><p>对象的原型链是对象的构造函数的原型一直到Object.prototype.<strong>proto</strong>组成的，因此通常我们说的某某对象的原型是指构造函数的原型(即<strong>proto</strong>属性)，而不是对象的原型对象(即prototype属性)</p><p>函数是特殊的对象，创建时会自动生成prototype属性，如A.prototype = {constructor: A}，非函数对象的prototype为undefined</p><p><a href="https://www.processon.com/diagraming/5cb35bbae4b069ac5a2699fa" target="_blank" rel="noopener">原型、原型链图解</a></p><p>instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;&#125;</span><br><span class="line">var a = new A();</span><br><span class="line">var b = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//a,b的原型链如下</span><br><span class="line">// a--&gt;A.prototype--&gt;Object.prototype--&gt;null</span><br><span class="line">a instanceof A // true</span><br><span class="line">a instanceof Object // true</span><br><span class="line">// b--&gt;Object.prototype--&gt;null</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h1&gt;&lt;p&gt;prototype属性指向原型对象，&lt;strong&gt;proto&lt;/strong&gt;属性指向构造函数的原型。&lt;/p&gt;
&lt;p&gt;对象的原型链是对象的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/es5/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://gwtjs.github.io/programming/es5/前端模块化/</id>
    <published>2019-07-31T16:15:51.795Z</published>
    <updated>2019-04-21T10:56:05.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>前端模块化的发展主要经历了以下四个阶段：</p><ol><li><p>原始实现阶段：使用函数/对象，一个函数或一个对象表示一个模块。函数方式存在全局命名空间污染问题，对象方式存在所有模块成员都对外暴露的问题；</p></li><li><p>闭包实现阶段：使用立即执行函数，返回一个模块。这种方式存在模块管理混乱的问题，比如A模块依赖B模块，则加载B模块的script标签就必须放在A模块的script的标签之前，当应用引入较多模块是，手动维护依赖不利于管理；</p></li><li><p>commonjs、amd、cmd规范阶段：nodejs的模块机制实现了commonjs规范，requirejs实现了amd规范，seajs实现了cmd规范。commonjs由于需要同步加载的原因无法用于浏览器端，amd、cmd的主要区别在于模块的加载时机不同。</p></li><li><p>es6的module规范阶段：es6原生提供了模块机制。</p></li></ol><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="commonjs规范："><a href="#commonjs规范：" class="headerlink" title="commonjs规范："></a>commonjs规范：</h2><h2 id="amd规范：官方介绍"><a href="#amd规范：官方介绍" class="headerlink" title="amd规范：官方介绍"></a>amd规范：<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">官方介绍</a></h2><ol><li><p>define()函数，用于定义模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure></li><li><p>define.amd属性，用于标识模块遵循amd规范</p></li><li><p>一个amd规范的简单伪代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>cmd规范：</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h1&gt;&lt;p&gt;前端模块化的发展主要经历了以下四个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;原始实现阶段：使用函数/对象，一个函数或一个对象表示一个模块。函数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/es5/bind%E3%80%81call%E3%80%81apply/"/>
    <id>http://gwtjs.github.io/programming/es5/bind、call、apply/</id>
    <published>2019-07-31T16:15:51.780Z</published>
    <updated>2019-04-21T10:56:14.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。返回一个原函数的拷贝，并拥有指定的this值和初始参数。</p><p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。返回调用有指定this值和参数的函数的结果。</p><p>call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。使用调用者提供的this值和参数调用该函数的返回值。若该方法没有返回值，则返回undefined。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>bind()方法</p><p>bind()方法的简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function(target, ...otherArgs) &#123;</span><br><span class="line">    const thisFun = this;</span><br><span class="line">    return function(...args) &#123;</span><br><span class="line">        return thisFun.call(target, ...otherArgs, ...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const a = &#123;name: &apos;a&apos;&#125;;</span><br><span class="line">let b = function(...args)&#123;return [this.name,...args]&#125;;</span><br><span class="line">b = b.myBind(a,1,2);</span><br><span class="line">b(); // 返回 [&quot;a&quot;, 1, 2]</span><br><span class="line">b(3,4); // 返回 [&quot;a&quot;, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>call()、apply()方法在调用者函数运行时改变调用者的this指向第一个参数。如果这个函数处于non-strict mode，且传入的第一个参数为null和undefined，则this值会自动指向全局对象(浏览器中就是window对象)；如果第一个参数为原始值(数字，字符串，布尔值)，this会指向该原始值的自动包装对象。</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h1&gt;&lt;p&gt;bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。返回
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/%E7%99%BB%E5%BD%95%E6%96%B9%E6%A1%88/"/>
    <id>http://gwtjs.github.io/programming/项目记录/博客后台/登录方案/</id>
    <published>2019-07-31T16:15:51.748Z</published>
    <updated>2019-07-19T14:29:14.370Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/%E8%8F%9C%E5%8D%95%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88/"/>
    <id>http://gwtjs.github.io/programming/项目记录/博客后台/菜单权限控制方案/</id>
    <published>2019-07-31T16:15:51.748Z</published>
    <updated>2019-07-19T14:29:31.351Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/element-ui%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5/"/>
    <id>http://gwtjs.github.io/programming/项目记录/博客后台/element-ui按需引入/</id>
    <published>2019-07-31T16:15:51.733Z</published>
    <updated>2019-07-19T14:28:45.034Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/xss%E3%80%81csrf%E9%98%B2%E5%BE%A1/"/>
    <id>http://gwtjs.github.io/programming/项目记录/博客后台/xss、csrf防御/</id>
    <published>2019-07-31T16:15:51.733Z</published>
    <updated>2019-07-19T14:30:14.183Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwtjs.github.io/programming/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0/%E5%9F%BA%E4%BA%8Eaxios%E7%9A%84%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%8F%8A%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://gwtjs.github.io/programming/项目记录/博客后台/基于axios的请求封装、错误处理及错误收集/</id>
    <published>2019-07-31T16:15:51.733Z</published>
    <updated>2019-07-19T14:30:45.054Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
